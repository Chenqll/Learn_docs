## 数据类型

### 内存、大小端

0x12345678 怎么放置到内存中？

将数据的低位（78），放到内存地址的低位，这种放置的方式，小端方式，little endian

将数据的高位（12），放到内存地址的低位，这种方式的方式，大端方式，big endian

x86 芯片、ARM 默认 小端方式。

### 有符号整型编码

有符号编码方案：补码（CSAPP）

规则：

- 最高为为符号位，0表示是正数，1表示是负数
- 如何解释十六进制：依照以下公式： -1*(符号位)*2^{若干次方} + (符号低一位)*2^{若干次方-1} + ...

0xFFFFFFFB => 1111 1111 1111 1111 1111 1111 1111 1011

```
-1*(2)^31 + (2)^30 + (2)^29 + ... 1*2^3 + 0*2^2 + 1*2^1 + 1*^0
```

补码的优点：当数据长度扩充是，往高位补符号位，则数学上的值是不变的。

### 浮点编码

科学计数法：我认为，它主要是解决了“数字唯一表达的问题”

1234.567 == 1.234567 * 10^3 == 12.34567 * 10^2 == 0.1234567 * 10^4

对于科学计数法表示的数字，3个部分：

1. 符号
2. 有效数字
3. 指数

而对于二进制而言，还有个 trick：有效数字的整数部分不要存（只可能是1）。

对于 float 而言，32 bit：

1. 符号： 1bit， 0代表正数，1代表负数
2. 有效数字：23 bit
3. 指数：8bit，-128~127

下面具体看一下，如何将一个小数编码为 float。

1. 转为二进制
2. 转为科学计数法
3. 根据以上三个步骤，找出三个部分的数据。**注意**：编码方案规定：指数+127 之后的结果，存储。

```c++
  float fValue = 5.625f;
  // 101.101
  // 1.01101 * 2^2
  
  // 符号: 0
  // 指数: 2+127 = 129  # 10000001
  // 01101

  // 0 10000001 01101000000000000000000
  // 0100 0000 1011 0100 0000 0000 0000 0000
  // 4    0    B    4    0    0    0    0
  // 0x40b40000
```

double: 1, 11, 52

half: 1, 5, 10
2.5345882


## 指针 I

指针的关键：

- 地址在哪里
- 解释方式（sizeof + 编码方案）

`void*` 表示 **只有地址，没有解释方式** 的指针。